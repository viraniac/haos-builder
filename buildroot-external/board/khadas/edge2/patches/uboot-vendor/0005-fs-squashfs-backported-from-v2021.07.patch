From 2c100dc73801b6386cfa7ecd1acfb8cbca1d0eac Mon Sep 17 00:00:00 2001
From: Gunjan Gupta <gunjan@wesion.com>
Date: Fri, 18 Apr 2025 14:10:46 +0000
Subject: [PATCH 5/5] fs/squashfs: backported from v2021.07

* fs/squashfs: new filesystem
* fs/squashfs: Add init and clean-up functions to decompression
* fs/squashfs: add support for LZO decompression
* fs/squashfs: replace sqfs_decompress() parameter
* fs/squashfs: Fix Coverity Scan defects
* fs/squashfs: Fix Coverity Scan defects
* fs/squashfs: parameter check sqfs_read_metablock()
* fs/squashfs: Fix index off by 1 for inode SQFS_LDIR_TYPE
* fs/squashfs: sqfs_opendir: fix some memory leaks and dangling pointers
* fs/squashfs: sqfs_opendir: simplify error handling
* fs/squashfs: sqfs_closedir: fix memory leak
* fs/squashfs: sqfs_split_path: fix memory leak and dangling pointers
* fs/squashfs: sqfs_read_directory_table: fix memory leak
* fs/squashfs: sqfs_search_dir: fix dangling pointer
* fs/squashfs: sqfs_search_dir: fix memory leaks
* fs/squashfs: sqfs_read_inode_table: fix dangling pointer
* fs/squashfs: sqfs_concat_tokens: check if malloc succeeds
* fs/squashfs: sqfs_size: fix dangling pointer dirs->entry
* fs/squashfs: sqfs_size: remove useless sqfs_closedir()
* fs/squashfs: sqfs_read: fix dangling pointer dirs->entry
* fs/squashfs: sqfs_read: remove useless sqfs_closedir()
* fs/squashfs: sqfs_read: fix memory leak
* fs/squashfs: sqfs_read: fix another memory leak
* fs/squashfs: sqfs_frag_lookup: simplify error handling
* fs/squashfs: sqfs_get_abs_path: fix error check
* fs/squashfs: sqfs_get_abs_path: fix possible memory leak on error
* fs/squashfs: sqfs_read: fix memory leak on finfo.blk_sizes
* fs/squashfs: sqfs_probe: fix possible memory leak on error
* fs/squashfs: sqfs_probe: reset cur_dev/cur_part_info to NULL on error
* fs/squashfs: sqfs_probe: use sqfs_decompressor_init() return value
* fs/squashfs: sqfs_read: don't write beyond buffer size
* fs/squashfs: sqfs_read: remove buggy offset functionality
* fs/squashfs: implement exists() function
* fs/squashfs: sqfs_close/sqfs_read_sblk: set ctxt.sblk to NULL after free
* fs/squashfs: Fix squashfs failing to load sparse files
* fs/squashfs: NULL dereference in sqfs_closedir()
* fs/squashfs: zero out unused fields in fs_dirent
* fs/squashfs: fix reading of fragmented files
---
 MAINTAINERS                     |    6 +
 common/spl/Kconfig              |    9 +
 fs/Kconfig                      |    2 +
 fs/Makefile                     |    2 +
 fs/fs.c                         |   18 +
 fs/squashfs/Kconfig             |   11 +
 fs/squashfs/Makefile            |    7 +
 fs/squashfs/sqfs.c              | 1723 +++++++++++++++++++++++++++++++
 fs/squashfs/sqfs_decompressor.c |   73 ++
 fs/squashfs/sqfs_decompressor.h |   60 ++
 fs/squashfs/sqfs_dir.c          |   92 ++
 fs/squashfs/sqfs_filesystem.h   |  306 ++++++
 fs/squashfs/sqfs_inode.c        |  160 +++
 fs/squashfs/sqfs_utils.h        |   49 +
 include/fs.h                    |    1 +
 include/squashfs.h              |   26 +
 16 files changed, 2545 insertions(+)
 create mode 100644 fs/squashfs/Kconfig
 create mode 100644 fs/squashfs/Makefile
 create mode 100644 fs/squashfs/sqfs.c
 create mode 100644 fs/squashfs/sqfs_decompressor.c
 create mode 100644 fs/squashfs/sqfs_decompressor.h
 create mode 100644 fs/squashfs/sqfs_dir.c
 create mode 100644 fs/squashfs/sqfs_filesystem.h
 create mode 100644 fs/squashfs/sqfs_inode.c
 create mode 100644 fs/squashfs/sqfs_utils.h
 create mode 100644 include/squashfs.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 06d9e8cc635..ce518407cbd 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -516,6 +516,12 @@ S:	Maintained
 F:	drivers/spmi/
 F:	include/spmi/
 
+SQUASHFS
+M:	Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+S:	Maintained
+F:	fs/squashfs/
+F:	include/sqfs.h
+
 TI SYSTEM SECURITY
 M:	Andrew F. Davis <afd@ti.com>
 S:	Supported
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index 2b557f08fa8..0106ff76e4f 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -380,6 +380,15 @@ config SPL_EXT_SUPPORT
 	  filesystem from within SPL. Support for the underlying block
 	  device (e.g. MMC or USB) must be enabled separately.
 
+config SPL_FS_SQUASHFS
+	bool "Support SquashFS filesystems"
+	select FS_SQUASHFS
+	help
+	  Enable support for SquashFS filesystems with SPL. This permits
+	  U-Boot (or Linux in Falcon mode) to be loaded from a SquashFS
+	  filesystem from within SPL. Support for the underlying block
+	  device (e.g. MMC or USB) must be enabled separately.
+
 config SPL_FAT_SUPPORT
 	bool "Support FAT filesystems"
 	select FS_FAT
diff --git a/fs/Kconfig b/fs/Kconfig
index e6803ac8cb2..e598bddc17f 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -20,4 +20,6 @@ source "fs/cramfs/Kconfig"
 
 source "fs/yaffs2/Kconfig"
 
+source "fs/squashfs/Kconfig"
+
 endmenu
diff --git a/fs/Makefile b/fs/Makefile
index b53c9d7cca7..8b9ae5fec82 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -9,6 +9,7 @@
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_FAT_SUPPORT) += fat/
 obj-$(CONFIG_SPL_EXT_SUPPORT) += ext4/
+obj-$(CONFIG_SPL_FS_SQUASHFS) += squashfs/
 else
 obj-y				+= fs.o
 
@@ -22,5 +23,6 @@ obj-$(CONFIG_SANDBOX) += sandbox/
 obj-$(CONFIG_CMD_UBIFS) += ubifs/
 obj-$(CONFIG_YAFFS2) += yaffs2/
 obj-$(CONFIG_CMD_ZFS) += zfs/
+obj-$(CONFIG_FS_SQUASHFS) += squashfs/
 endif
 obj-y += fs_internal.o
diff --git a/fs/fs.c b/fs/fs.c
index 60aca0f7678..062ade634a4 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -17,6 +17,7 @@
 #include <asm/io.h>
 #include <div64.h>
 #include <linux/math64.h>
+#include <squashfs.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -218,6 +219,23 @@ static struct fstype_info fstypes[] = {
 		.uuid = fs_uuid_unsupported,
 		.opendir = fs_opendir_unsupported,
 	},
+#endif
+#if IS_ENABLED(CONFIG_FS_SQUASHFS)
+	{
+		.fstype = FS_TYPE_SQUASHFS,
+		.name = "squashfs",
+		.probe = sqfs_probe,
+		.opendir = sqfs_opendir,
+		.readdir = sqfs_readdir,
+		.ls = fs_ls_generic,
+		.read = sqfs_read,
+		.size = sqfs_size,
+		.close = sqfs_close,
+		.closedir = sqfs_closedir,
+		.exists = sqfs_exists,
+		.uuid = fs_uuid_unsupported,
+		.write = fs_write_unsupported,
+	},
 #endif
 	{
 		.fstype = FS_TYPE_ANY,
diff --git a/fs/squashfs/Kconfig b/fs/squashfs/Kconfig
new file mode 100644
index 00000000000..42c4d6ab52f
--- /dev/null
+++ b/fs/squashfs/Kconfig
@@ -0,0 +1,11 @@
+config FS_SQUASHFS
+	bool "Enable SquashFS filesystem support"
+	select LZO
+	help
+	  This provides support for reading images from SquashFS filesystem.
+	  Squashfs is a compressed read-only filesystem for Linux.
+	  It uses zlib, lz4, lzo, or xz compression to compress files, inodes
+	  and directories. Squashfs is intended for general read-only
+	  filesystem use, for archival use (i.e. in cases where a .tar.gz file
+	  may be used), and in constrained block device/memory systems (e.g.
+	  embedded systems) where low overhead is needed.
diff --git a/fs/squashfs/Makefile b/fs/squashfs/Makefile
new file mode 100644
index 00000000000..ba66ee821c2
--- /dev/null
+++ b/fs/squashfs/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+obj-$(CONFIG_$(SPL_)FS_SQUASHFS) = sqfs.o \
+				sqfs_inode.o \
+				sqfs_dir.o \
+				sqfs_decompressor.o
diff --git a/fs/squashfs/sqfs.c b/fs/squashfs/sqfs.c
new file mode 100644
index 00000000000..cfdc5a3445e
--- /dev/null
+++ b/fs/squashfs/sqfs.c
@@ -0,0 +1,1723 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ *
+ * sqfs.c: SquashFS filesystem implementation
+ */
+
+#include <asm/unaligned.h>
+#include <errno.h>
+#include <fs.h>
+#include <linux/types.h>
+#include <linux/byteorder/little_endian.h>
+#include <linux/byteorder/generic.h>
+#include <memalign.h>
+#include <stdlib.h>
+#include <linux/string.h>
+#include <squashfs.h>
+#include <part.h>
+
+#include "sqfs_decompressor.h"
+#include "sqfs_filesystem.h"
+#include "sqfs_utils.h"
+
+static struct squashfs_ctxt ctxt;
+
+static int sqfs_disk_read(__u32 block, __u32 nr_blocks, void *buf)
+{
+	ulong ret;
+
+	if (!ctxt.cur_dev)
+		return -1;
+
+	ret = blk_dread(ctxt.cur_dev, ctxt.cur_part_info.start + block,
+			nr_blocks, buf);
+
+	if (ret != nr_blocks)
+		return -1;
+
+	return ret;
+}
+
+static int sqfs_read_sblk(struct squashfs_super_block **sblk)
+{
+	*sblk = malloc_cache_aligned(ctxt.cur_dev->blksz);
+	if (!*sblk)
+		return -ENOMEM;
+
+	if (sqfs_disk_read(0, 1, *sblk) != 1) {
+		free(*sblk);
+		sblk = NULL;
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sqfs_count_tokens(const char *filename)
+{
+	int token_count = 1, l;
+
+	for (l = 1; l < strlen(filename); l++) {
+		if (filename[l] == '/')
+			token_count++;
+	}
+
+	/* Ignore trailing '/' in path */
+	if (filename[strlen(filename) - 1] == '/')
+		token_count--;
+
+	if (!token_count)
+		token_count = 1;
+
+	return token_count;
+}
+
+/*
+ * Calculates how many blocks are needed for the buffer used in sqfs_disk_read.
+ * The memory section (e.g. inode table) start offset and its end (i.e. the next
+ * table start) must be specified. It also calculates the offset from which to
+ * start reading the buffer.
+ */
+static int sqfs_calc_n_blks(__le64 start, __le64 end, u64 *offset)
+{
+	u64 start_, table_size;
+
+	table_size = le64_to_cpu(end) - le64_to_cpu(start);
+	start_ = le64_to_cpu(start) / ctxt.cur_dev->blksz;
+	*offset = le64_to_cpu(start) - (start_ * ctxt.cur_dev->blksz);
+
+	return DIV_ROUND_UP(table_size + *offset, ctxt.cur_dev->blksz);
+}
+
+/*
+ * Retrieves fragment block entry and returns true if the fragment block is
+ * compressed
+ */
+static int sqfs_frag_lookup(u32 inode_fragment_index,
+			    struct squashfs_fragment_block_entry *e)
+{
+	u64 start, n_blks, src_len, table_offset, start_block;
+	unsigned char *metadata_buffer, *metadata, *table;
+	struct squashfs_fragment_block_entry *entries;
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	unsigned long dest_len;
+	int block, offset, ret;
+	u16 header;
+
+	metadata_buffer = NULL;
+	entries = NULL;
+	table = NULL;
+
+	if (inode_fragment_index >= get_unaligned_le32(&sblk->fragments))
+		return -EINVAL;
+
+	start = get_unaligned_le64(&sblk->fragment_table_start) /
+		ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(sblk->fragment_table_start,
+				  sblk->export_table_start,
+				  &table_offset);
+
+	/* Allocate a proper sized buffer to store the fragment index table */
+	table = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!table) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (sqfs_disk_read(start, n_blks, table) < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	block = SQFS_FRAGMENT_INDEX(inode_fragment_index);
+	offset = SQFS_FRAGMENT_INDEX_OFFSET(inode_fragment_index);
+
+	/*
+	 * Get the start offset of the metadata block that contains the right
+	 * fragment block entry
+	 */
+	start_block = get_unaligned_le64(table + table_offset + block *
+					 sizeof(u64));
+
+	start = start_block / ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(cpu_to_le64(start_block),
+				  sblk->fragment_table_start, &table_offset);
+
+	metadata_buffer = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!metadata_buffer) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (sqfs_disk_read(start, n_blks, metadata_buffer) < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Every metadata block starts with a 16-bit header */
+	header = get_unaligned_le16(metadata_buffer + table_offset);
+	metadata = metadata_buffer + table_offset + SQFS_HEADER_SIZE;
+
+	if (!metadata || !header) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	entries = malloc(SQFS_METADATA_BLOCK_SIZE);
+	if (!entries) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (SQFS_COMPRESSED_METADATA(header)) {
+		src_len = SQFS_METADATA_SIZE(header);
+		dest_len = SQFS_METADATA_BLOCK_SIZE;
+		ret = sqfs_decompress(&ctxt, entries, &dest_len, metadata,
+				      src_len);
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+	} else {
+		memcpy(entries, metadata, SQFS_METADATA_SIZE(header));
+	}
+
+	*e = entries[offset];
+	ret = SQFS_COMPRESSED_BLOCK(e->size);
+
+out:
+	free(entries);
+	free(metadata_buffer);
+	free(table);
+
+	return ret;
+}
+
+/*
+ * The entry name is a flexible array member, and we don't know its size before
+ * actually reading the entry. So we need a first copy to retrieve this size so
+ * we can finally copy the whole struct.
+ */
+static int sqfs_read_entry(struct squashfs_directory_entry **dest, void *src)
+{
+	struct squashfs_directory_entry *tmp;
+	u16 sz;
+
+	tmp = src;
+	sz = get_unaligned_le16(src + sizeof(*tmp) - sizeof(u16));
+	/*
+	 * 'src' points to the begin of a directory entry, and 'sz' gets its
+	 * 'name_size' member's value. name_size is actually the string
+	 * length - 1, so adding 2 compensates this difference and adds space
+	 * for the trailling null byte.
+	 */
+	*dest = malloc(sizeof(*tmp) + sz + 2);
+	if (!*dest)
+		return -ENOMEM;
+
+	memcpy(*dest, src, sizeof(*tmp) + sz + 1);
+	(*dest)->name[sz + 1] = '\0';
+
+	return 0;
+}
+
+static int sqfs_get_tokens_length(char **tokens, int count)
+{
+	int length = 0, i;
+
+	/*
+	 * 1 is added to the result of strlen to consider the slash separator
+	 * between the tokens.
+	 */
+	for (i = 0; i < count; i++)
+		length += strlen(tokens[i]) + 1;
+
+	return length;
+}
+
+/* Takes a token list and returns a single string with '/' as separator. */
+static char *sqfs_concat_tokens(char **token_list, int token_count)
+{
+	char *result;
+	int i, length = 0, offset = 0;
+
+	length = sqfs_get_tokens_length(token_list, token_count);
+
+	result = malloc(length + 1);
+	if (!result)
+		return NULL;
+
+	result[length] = '\0';
+
+	for (i = 0; i < token_count; i++) {
+		strcpy(result + offset, token_list[i]);
+		offset += strlen(token_list[i]);
+		result[offset++] = '/';
+	}
+
+	return result;
+}
+
+/*
+ * Differently from sqfs_concat_tokens, sqfs_join writes the result into a
+ * previously allocated string, and returns the number of bytes written.
+ */
+static int sqfs_join(char **strings, char *dest, int start, int end,
+		     char separator)
+{
+	int i, offset = 0;
+
+	for (i = start; i < end; i++) {
+		strcpy(dest + offset, strings[i]);
+		offset += strlen(strings[i]);
+		if (i < end - 1)
+			dest[offset++] = separator;
+	}
+
+	return offset;
+}
+
+/*
+ * Fills the given token list using its size (count) and a source string (str)
+ */
+static int sqfs_tokenize(char **tokens, int count, const char *str)
+{
+	int i, j, ret = 0;
+	char *aux, *strc;
+
+	strc = strdup(str);
+	if (!strc)
+		return -ENOMEM;
+
+	if (!strcmp(strc, "/")) {
+		tokens[0] = strdup(strc);
+		if (!tokens[0]) {
+			ret = -ENOMEM;
+			goto free_strc;
+		}
+	} else {
+		for (j = 0; j < count; j++) {
+			aux = strtok(!j ? strc : NULL, "/");
+			tokens[j] = strdup(aux);
+			if (!tokens[j]) {
+				for (i = 0; i < j; i++)
+					free(tokens[i]);
+				ret = -ENOMEM;
+				goto free_strc;
+			}
+		}
+	}
+
+free_strc:
+	free(strc);
+
+	return ret;
+}
+
+/*
+ * Remove last 'updir + 1' tokens from the base path tokens list. This leaves us
+ * with a token list containing only the tokens needed to form the resolved
+ * path, and returns the decremented size of the token list.
+ */
+static int sqfs_clean_base_path(char **base, int count, int updir)
+{
+	int i;
+
+	for (i = count - updir - 1; i < count; i++)
+		free(base[i]);
+
+	return count - updir - 1;
+}
+
+/*
+ * Given the base ("current dir.") path and the relative one, generate the
+ * absolute path.
+ */
+static char *sqfs_get_abs_path(const char *base, const char *rel)
+{
+	char **base_tokens, **rel_tokens, *resolved = NULL;
+	int ret, bc, rc, i, updir = 0, resolved_size = 0, offset = 0;
+
+	base_tokens = NULL;
+	rel_tokens = NULL;
+
+	/* Memory allocation for the token lists */
+	bc = sqfs_count_tokens(base);
+	rc = sqfs_count_tokens(rel);
+	if (bc < 1 || rc < 1)
+		return NULL;
+
+	base_tokens = calloc(bc, sizeof(char *));
+	if (!base_tokens)
+		return NULL;
+
+	rel_tokens = calloc(rc, sizeof(char *));
+	if (!rel_tokens)
+		goto out;
+
+	/* Fill token lists */
+	ret = sqfs_tokenize(base_tokens, bc, base);
+	if (ret)
+		goto out;
+
+	ret = sqfs_tokenize(rel_tokens, rc, rel);
+	if (ret)
+		goto out;
+
+	/* count '..' occurrences in target path */
+	for (i = 0; i < rc; i++) {
+		if (!strcmp(rel_tokens[i], ".."))
+			updir++;
+	}
+
+	/* Remove the last token and the '..' occurrences */
+	bc = sqfs_clean_base_path(base_tokens, bc, updir);
+	if (bc < 0)
+		goto out;
+
+	/* Calculate resolved path size */
+	if (!bc)
+		resolved_size++;
+
+	resolved_size += sqfs_get_tokens_length(base_tokens, bc) +
+		sqfs_get_tokens_length(rel_tokens, rc);
+
+	resolved = malloc(resolved_size + 1);
+	if (!resolved)
+		goto out;
+
+	/* Set resolved path */
+	memset(resolved, '\0', resolved_size + 1);
+	offset += sqfs_join(base_tokens, resolved + offset, 0, bc, '/');
+	resolved[offset++] = '/';
+	offset += sqfs_join(rel_tokens, resolved + offset, updir, rc, '/');
+
+out:
+	if (rel_tokens)
+		for (i = 0; i < rc; i++)
+			free(rel_tokens[i]);
+	if (base_tokens)
+		for (i = 0; i < bc; i++)
+			free(base_tokens[i]);
+
+	free(rel_tokens);
+	free(base_tokens);
+
+	return resolved;
+}
+
+static char *sqfs_resolve_symlink(struct squashfs_symlink_inode *sym,
+				  const char *base_path)
+{
+	char *resolved, *target;
+	u32 sz;
+
+	sz = get_unaligned_le32(&sym->symlink_size);
+	target = malloc(sz + 1);
+	if (!target)
+		return NULL;
+
+	/*
+	 * There is no trailling null byte in the symlink's target path, so a
+	 * copy is made and a '\0' is added at its end.
+	 */
+	target[sz] = '\0';
+	/* Get target name (relative path) */
+	strncpy(target, sym->symlink, sz);
+
+	/* Relative -> absolute path conversion */
+	resolved = sqfs_get_abs_path(base_path, target);
+
+	free(target);
+
+	return resolved;
+}
+
+/*
+ * m_list contains each metadata block's position, and m_count is the number of
+ * elements of m_list. Those metadata blocks come from the compressed directory
+ * table.
+ */
+static int sqfs_search_dir(struct squashfs_dir_stream *dirs, char **token_list,
+			   int token_count, u32 *m_list, int m_count)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	char *path, *target, **sym_tokens, *res, *rem;
+	int j, ret = 0, new_inode_number, offset;
+	struct squashfs_symlink_inode *sym;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_dir_inode *dir;
+	struct fs_dir_stream *dirsp;
+	struct fs_dirent *dent;
+	unsigned char *table;
+
+	res = NULL;
+	rem = NULL;
+	path = NULL;
+	target = NULL;
+	sym_tokens = NULL;
+
+	dirsp = (struct fs_dir_stream *)dirs;
+
+	/* Start by root inode */
+	table = sqfs_find_inode(dirs->inode_table, le32_to_cpu(sblk->inodes),
+				sblk->inodes, sblk->block_size);
+
+	dir = (struct squashfs_dir_inode *)table;
+	ldir = (struct squashfs_ldir_inode *)table;
+
+	/* get directory offset in directory table */
+	offset = sqfs_dir_offset(table, m_list, m_count);
+	dirs->table = &dirs->dir_table[offset];
+
+	/* Setup directory header */
+	dirs->dir_header = malloc(SQFS_DIR_HEADER_SIZE);
+	if (!dirs->dir_header)
+		return -ENOMEM;
+
+	memcpy(dirs->dir_header, dirs->table, SQFS_DIR_HEADER_SIZE);
+
+	/* Initialize squashfs_dir_stream members */
+	dirs->table += SQFS_DIR_HEADER_SIZE;
+	dirs->size = get_unaligned_le16(&dir->file_size) - SQFS_DIR_HEADER_SIZE;
+	dirs->entry_count = dirs->dir_header->count + 1;
+
+	/* No path given -> root directory */
+	if (!strcmp(token_list[0], "/")) {
+		dirs->table = &dirs->dir_table[offset];
+		memcpy(&dirs->i_dir, dir, sizeof(*dir));
+		return 0;
+	}
+
+	for (j = 0; j < token_count; j++) {
+		if (!sqfs_is_dir(get_unaligned_le16(&dir->inode_type))) {
+			printf("** Cannot find directory. **\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		while (!sqfs_readdir(dirsp, &dent)) {
+			ret = strcmp(dent->name, token_list[j]);
+			if (!ret)
+				break;
+			free(dirs->entry);
+			dirs->entry = NULL;
+		}
+
+		if (ret) {
+			printf("** Cannot find directory. **\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* Redefine inode as the found token */
+		new_inode_number = dirs->entry->inode_offset +
+			dirs->dir_header->inode_number;
+
+		/* Get reference to inode in the inode table */
+		table = sqfs_find_inode(dirs->inode_table, new_inode_number,
+					sblk->inodes, sblk->block_size);
+		dir = (struct squashfs_dir_inode *)table;
+
+		/* Check for symbolic link and inode type sanity */
+		if (get_unaligned_le16(&dir->inode_type) == SQFS_SYMLINK_TYPE) {
+			sym = (struct squashfs_symlink_inode *)table;
+			/* Get first j + 1 tokens */
+			path = sqfs_concat_tokens(token_list, j + 1);
+			if (!path) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			/* Resolve for these tokens */
+			target = sqfs_resolve_symlink(sym, path);
+			if (!target) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			/* Join remaining tokens */
+			rem = sqfs_concat_tokens(token_list + j + 1, token_count -
+						 j - 1);
+			if (!rem) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			/* Concatenate remaining tokens and symlink's target */
+			res = malloc(strlen(rem) + strlen(target) + 1);
+			if (!res) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			strcpy(res, target);
+			res[strlen(target)] = '/';
+			strcpy(res + strlen(target) + 1, rem);
+			token_count = sqfs_count_tokens(res);
+
+			if (token_count < 0) {
+				ret = -EINVAL;
+				goto out;
+			}
+
+			sym_tokens = malloc(token_count * sizeof(char *));
+			if (!sym_tokens) {
+				ret = -EINVAL;
+				goto out;
+			}
+
+			/* Fill tokens list */
+			ret = sqfs_tokenize(sym_tokens, token_count, res);
+			if (ret) {
+				ret = -EINVAL;
+				goto out;
+			}
+			free(dirs->entry);
+			dirs->entry = NULL;
+
+			ret = sqfs_search_dir(dirs, sym_tokens, token_count,
+					      m_list, m_count);
+			goto out;
+		} else if (!sqfs_is_dir(get_unaligned_le16(&dir->inode_type))) {
+			printf("** Cannot find directory. **\n");
+			free(dirs->entry);
+			dirs->entry = NULL;
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* Check if it is an extended dir. */
+		if (get_unaligned_le16(&dir->inode_type) == SQFS_LDIR_TYPE)
+			ldir = (struct squashfs_ldir_inode *)table;
+
+		/* Get dir. offset into the directory table */
+		offset = sqfs_dir_offset(table, m_list, m_count);
+		dirs->table = &dirs->dir_table[offset];
+
+		/* Copy directory header */
+		memcpy(dirs->dir_header, &dirs->dir_table[offset],
+		       SQFS_DIR_HEADER_SIZE);
+
+		/* Check for empty directory */
+		if (sqfs_is_empty_dir(table)) {
+			printf("Empty directory.\n");
+			free(dirs->entry);
+			dirs->entry = NULL;
+			ret = SQFS_EMPTY_DIR;
+			goto out;
+		}
+
+		dirs->table += SQFS_DIR_HEADER_SIZE;
+		dirs->size = get_unaligned_le16(&dir->file_size);
+		dirs->entry_count = dirs->dir_header->count + 1;
+		dirs->size -= SQFS_DIR_HEADER_SIZE;
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	offset = sqfs_dir_offset(table, m_list, m_count);
+	dirs->table = &dirs->dir_table[offset];
+
+	if (get_unaligned_le16(&dir->inode_type) == SQFS_DIR_TYPE)
+		memcpy(&dirs->i_dir, dir, sizeof(*dir));
+	else
+		memcpy(&dirs->i_ldir, ldir, sizeof(*ldir));
+
+out:
+	free(res);
+	free(rem);
+	free(path);
+	free(target);
+	free(sym_tokens);
+	return ret;
+}
+
+/*
+ * Inode and directory tables are stored as a series of metadata blocks, and
+ * given the compressed size of this table, we can calculate how much metadata
+ * blocks are needed to store the result of the decompression, since a
+ * decompressed metadata block should have a size of 8KiB.
+ */
+static int sqfs_count_metablks(void *table, u32 offset, int table_size)
+{
+	int count = 0, cur_size = 0, ret;
+	u32 data_size;
+	bool comp;
+
+	do {
+		ret = sqfs_read_metablock(table, offset + cur_size, &comp,
+					  &data_size);
+		if (ret)
+			return -EINVAL;
+		cur_size += data_size + SQFS_HEADER_SIZE;
+		count++;
+	} while (cur_size < table_size);
+
+	return count;
+}
+
+/*
+ * Storing the metadata blocks header's positions will be useful while looking
+ * for an entry in the directory table, using the reference (index and offset)
+ * given by its inode.
+ */
+static int sqfs_get_metablk_pos(u32 *pos_list, void *table, u32 offset,
+				int metablks_count)
+{
+	u32 data_size, cur_size = 0;
+	int j, ret = 0;
+	bool comp;
+
+	if (!metablks_count)
+		return -EINVAL;
+
+	for (j = 0; j < metablks_count; j++) {
+		ret = sqfs_read_metablock(table, offset + cur_size, &comp,
+					  &data_size);
+		if (ret)
+			return -EINVAL;
+
+		cur_size += data_size + SQFS_HEADER_SIZE;
+		pos_list[j] = cur_size;
+	}
+
+	return ret;
+}
+
+static int sqfs_read_inode_table(unsigned char **inode_table)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	u64 start, n_blks, table_offset, table_size;
+	int j, ret = 0, metablks_count;
+	unsigned char *src_table, *itb;
+	u32 src_len, dest_offset = 0;
+	unsigned long dest_len = 0;
+	bool compressed;
+
+	table_size = get_unaligned_le64(&sblk->directory_table_start) -
+		get_unaligned_le64(&sblk->inode_table_start);
+	start = get_unaligned_le64(&sblk->inode_table_start) /
+		ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(sblk->inode_table_start,
+				  sblk->directory_table_start, &table_offset);
+
+	/* Allocate a proper sized buffer (itb) to store the inode table */
+	itb = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!itb)
+		return -ENOMEM;
+
+	if (sqfs_disk_read(start, n_blks, itb) < 0) {
+		ret = -EINVAL;
+		goto free_itb;
+	}
+
+	/* Parse inode table (metadata block) header */
+	ret = sqfs_read_metablock(itb, table_offset, &compressed, &src_len);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_itb;
+	}
+
+	/* Calculate size to store the whole decompressed table */
+	metablks_count = sqfs_count_metablks(itb, table_offset, table_size);
+	if (metablks_count < 1) {
+		ret = -EINVAL;
+		goto free_itb;
+	}
+
+	*inode_table = malloc(metablks_count * SQFS_METADATA_BLOCK_SIZE);
+	if (!*inode_table) {
+		ret = -ENOMEM;
+		goto free_itb;
+	}
+
+	src_table = itb + table_offset + SQFS_HEADER_SIZE;
+
+	/* Extract compressed Inode table */
+	for (j = 0; j < metablks_count; j++) {
+		sqfs_read_metablock(itb, table_offset, &compressed, &src_len);
+		if (compressed) {
+			dest_len = SQFS_METADATA_BLOCK_SIZE;
+			ret = sqfs_decompress(&ctxt, *inode_table +
+					      dest_offset, &dest_len,
+					      src_table, src_len);
+			if (ret) {
+				free(*inode_table);
+				*inode_table = NULL;
+				goto free_itb;
+			}
+
+			dest_offset += dest_len;
+		} else {
+			memcpy(*inode_table + (j * SQFS_METADATA_BLOCK_SIZE),
+			       src_table, src_len);
+		}
+
+		/*
+		 * Offsets to the decompression destination, to the metadata
+		 * buffer 'itb' and to the decompression source, respectively.
+		 */
+
+		table_offset += src_len + SQFS_HEADER_SIZE;
+		src_table += src_len + SQFS_HEADER_SIZE;
+	}
+
+free_itb:
+	free(itb);
+
+	return ret;
+}
+
+static int sqfs_read_directory_table(unsigned char **dir_table, u32 **pos_list)
+{
+	u64 start, n_blks, table_offset, table_size;
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	int j, ret = 0, metablks_count = -1;
+	unsigned char *src_table, *dtb;
+	u32 src_len, dest_offset = 0;
+	unsigned long dest_len = 0;
+	bool compressed;
+
+	*dir_table = NULL;
+	*pos_list = NULL;
+	/* DIRECTORY TABLE */
+	table_size = get_unaligned_le64(&sblk->fragment_table_start) -
+		get_unaligned_le64(&sblk->directory_table_start);
+	start = get_unaligned_le64(&sblk->directory_table_start) /
+		ctxt.cur_dev->blksz;
+	n_blks = sqfs_calc_n_blks(sblk->directory_table_start,
+				  sblk->fragment_table_start, &table_offset);
+
+	/* Allocate a proper sized buffer (dtb) to store the directory table */
+	dtb = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+	if (!dtb)
+		return -ENOMEM;
+
+	if (sqfs_disk_read(start, n_blks, dtb) < 0)
+		goto out;
+
+	/* Parse directory table (metadata block) header */
+	ret = sqfs_read_metablock(dtb, table_offset, &compressed, &src_len);
+	if (ret)
+		goto out;
+
+	/* Calculate total size to store the whole decompressed table */
+	metablks_count = sqfs_count_metablks(dtb, table_offset, table_size);
+	if (metablks_count < 1)
+		goto out;
+
+	*dir_table = malloc(metablks_count * SQFS_METADATA_BLOCK_SIZE);
+	if (!*dir_table)
+		goto out;
+
+	*pos_list = malloc(metablks_count * sizeof(u32));
+	if (!*pos_list)
+		goto out;
+
+	ret = sqfs_get_metablk_pos(*pos_list, dtb, table_offset,
+				   metablks_count);
+	if (ret) {
+		metablks_count = -1;
+		goto out;
+	}
+
+	src_table = dtb + table_offset + SQFS_HEADER_SIZE;
+
+	/* Extract compressed Directory table */
+	dest_offset = 0;
+	for (j = 0; j < metablks_count; j++) {
+		sqfs_read_metablock(dtb, table_offset, &compressed, &src_len);
+		if (compressed) {
+			dest_len = SQFS_METADATA_BLOCK_SIZE;
+			ret = sqfs_decompress(&ctxt, *dir_table +
+					      (j * SQFS_METADATA_BLOCK_SIZE),
+					      &dest_len, src_table, src_len);
+			if (ret) {
+				metablks_count = -1;
+				goto out;
+			}
+
+			if (dest_len < SQFS_METADATA_BLOCK_SIZE) {
+				dest_offset += dest_len;
+				break;
+			}
+
+			dest_offset += dest_len;
+		} else {
+			memcpy(*dir_table + (j * SQFS_METADATA_BLOCK_SIZE),
+			       src_table, src_len);
+		}
+
+		/*
+		 * Offsets to the decompression destination, to the metadata
+		 * buffer 'dtb' and to the decompression source, respectively.
+		 */
+		table_offset += src_len + SQFS_HEADER_SIZE;
+		src_table += src_len + SQFS_HEADER_SIZE;
+	}
+
+out:
+	if (metablks_count < 1) {
+		free(*dir_table);
+		free(*pos_list);
+		*dir_table = NULL;
+		*pos_list = NULL;
+	}
+	free(dtb);
+
+	return metablks_count;
+}
+
+int sqfs_opendir(const char *filename, struct fs_dir_stream **dirsp)
+{
+	unsigned char *inode_table = NULL, *dir_table = NULL;
+	int j, token_count = 0, ret = 0, metablks_count;
+	struct squashfs_dir_stream *dirs;
+	char **token_list = NULL, *path = NULL;
+	u32 *pos_list = NULL;
+
+	dirs = calloc(1, sizeof(*dirs));
+	if (!dirs)
+		return -EINVAL;
+
+	/* these should be set to NULL to prevent dangling pointers */
+	dirs->dir_header = NULL;
+	dirs->entry = NULL;
+	dirs->table = NULL;
+	dirs->inode_table = NULL;
+	dirs->dir_table = NULL;
+
+	ret = sqfs_read_inode_table(&inode_table);
+	if (ret) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	metablks_count = sqfs_read_directory_table(&dir_table, &pos_list);
+	if (metablks_count < 1) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Tokenize filename */
+	token_count = sqfs_count_tokens(filename);
+	if (token_count < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	path = strdup(filename);
+	if (!path) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	token_list = malloc(token_count * sizeof(char *));
+	if (!token_list) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Fill tokens list */
+	ret = sqfs_tokenize(token_list, token_count, path);
+	if (ret)
+		goto out;
+	/*
+	 * ldir's (extended directory) size is greater than dir, so it works as
+	 * a general solution for the malloc size, since 'i' is a union.
+	 */
+	dirs->inode_table = inode_table;
+	dirs->dir_table = dir_table;
+	ret = sqfs_search_dir(dirs, token_list, token_count, pos_list,
+			      metablks_count);
+	if (ret)
+		goto out;
+
+	if (le16_to_cpu(dirs->i_dir.inode_type) == SQFS_DIR_TYPE)
+		dirs->size = le16_to_cpu(dirs->i_dir.file_size);
+	else
+		dirs->size = le32_to_cpu(dirs->i_ldir.file_size);
+
+	/* Setup directory header */
+	memcpy(dirs->dir_header, dirs->table, SQFS_DIR_HEADER_SIZE);
+	dirs->entry_count = dirs->dir_header->count + 1;
+	dirs->size -= SQFS_DIR_HEADER_SIZE;
+
+	/* Setup entry */
+	dirs->entry = NULL;
+	dirs->table += SQFS_DIR_HEADER_SIZE;
+
+	*dirsp = (struct fs_dir_stream *)dirs;
+
+out:
+	for (j = 0; j < token_count; j++)
+		free(token_list[j]);
+	free(token_list);
+	free(pos_list);
+	free(path);
+	if (ret) {
+		free(inode_table);
+		free(dirs);
+	}
+
+	return ret;
+}
+
+int sqfs_readdir(struct fs_dir_stream *fs_dirs, struct fs_dirent **dentp)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	struct squashfs_dir_stream *dirs;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_base_inode *base;
+	struct squashfs_reg_inode *reg;
+	int i_number, offset = 0, ret;
+	struct fs_dirent *dent;
+	unsigned char *ipos;
+
+	dirs = (struct squashfs_dir_stream *)fs_dirs;
+	if (!dirs->size) {
+		*dentp = NULL;
+		return -SQFS_STOP_READDIR;
+	}
+
+	dent = &dirs->dentp;
+
+	if (!dirs->entry_count) {
+		if (dirs->size > SQFS_DIR_HEADER_SIZE) {
+			dirs->size -= SQFS_DIR_HEADER_SIZE;
+		} else {
+			*dentp = NULL;
+			dirs->size = 0;
+			return -SQFS_STOP_READDIR;
+		}
+
+		if (dirs->size > SQFS_EMPTY_FILE_SIZE) {
+			/* Read follow-up (emitted) dir. header */
+			memcpy(dirs->dir_header, dirs->table,
+			       SQFS_DIR_HEADER_SIZE);
+			dirs->entry_count = dirs->dir_header->count + 1;
+			ret = sqfs_read_entry(&dirs->entry, dirs->table +
+					      SQFS_DIR_HEADER_SIZE);
+			if (ret)
+				return -SQFS_STOP_READDIR;
+
+			dirs->table += SQFS_DIR_HEADER_SIZE;
+		}
+	} else {
+		ret = sqfs_read_entry(&dirs->entry, dirs->table);
+		if (ret)
+			return -SQFS_STOP_READDIR;
+	}
+
+	i_number = dirs->dir_header->inode_number + dirs->entry->inode_offset;
+	ipos = sqfs_find_inode(dirs->inode_table, i_number, sblk->inodes,
+			       sblk->block_size);
+
+	base = (struct squashfs_base_inode *)ipos;
+
+	/* Set entry type and size */
+	switch (dirs->entry->type) {
+	case SQFS_DIR_TYPE:
+	case SQFS_LDIR_TYPE:
+		dent->type = FS_DT_DIR;
+		break;
+	case SQFS_REG_TYPE:
+	case SQFS_LREG_TYPE:
+		/*
+		 * Entries do not differentiate extended from regular types, so
+		 * it needs to be verified manually.
+		 */
+		if (get_unaligned_le16(&base->inode_type) == SQFS_LREG_TYPE) {
+			lreg = (struct squashfs_lreg_inode *)ipos;
+			dent->size = get_unaligned_le64(&lreg->file_size);
+		} else {
+			reg = (struct squashfs_reg_inode *)ipos;
+			dent->size = get_unaligned_le32(&reg->file_size);
+		}
+
+		dent->type = FS_DT_REG;
+		break;
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+		dent->type = SQFS_MISC_ENTRY_TYPE;
+		break;
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE:
+		dent->type = FS_DT_LNK;
+		break;
+	default:
+		return -SQFS_STOP_READDIR;
+	}
+
+	/* Set entry name */
+	strncpy(dent->name, dirs->entry->name, dirs->entry->name_size + 1);
+	dent->name[dirs->entry->name_size + 1] = '\0';
+
+	offset = dirs->entry->name_size + 1 + SQFS_ENTRY_BASE_LENGTH;
+	dirs->entry_count--;
+
+	/* Decrement size to be read */
+	if (dirs->size > offset)
+		dirs->size -= offset;
+	else
+		dirs->size = 0;
+
+	/* Keep a reference to the current entry before incrementing it */
+	dirs->table += offset;
+
+	*dentp = dent;
+
+	return 0;
+}
+
+int sqfs_probe(struct blk_desc *fs_dev_desc, struct disk_partition *fs_partition)
+{
+	struct squashfs_super_block *sblk;
+	int ret;
+
+	ctxt.cur_dev = fs_dev_desc;
+	ctxt.cur_part_info = *fs_partition;
+
+	ret = sqfs_read_sblk(&sblk);
+	if (ret)
+		goto error;
+
+	/* Make sure it has a valid SquashFS magic number*/
+	if (get_unaligned_le32(&sblk->s_magic) != SQFS_MAGIC_NUMBER) {
+		printf("Bad magic number for SquashFS image.\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	ctxt.sblk = sblk;
+
+	ret = sqfs_decompressor_init(&ctxt);
+	if (ret) {
+		goto error;
+	}
+
+	return 0;
+error:
+	ctxt.cur_dev = NULL;
+	free(ctxt.sblk);
+	ctxt.sblk = NULL;
+	return ret;
+}
+
+static char *sqfs_basename(char *path)
+{
+	char *fname;
+
+	fname = path + strlen(path) - 1;
+	while (fname >= path) {
+		if (*fname == '/') {
+			fname++;
+			break;
+		}
+
+		fname--;
+	}
+
+	return fname;
+}
+
+static char *sqfs_dirname(char *path)
+{
+	char *fname;
+
+	fname = sqfs_basename(path);
+	--fname;
+	*fname = '\0';
+
+	return path;
+}
+
+/*
+ * Takes a path to file and splits it in two parts: the filename itself and the
+ * directory's path, e.g.:
+ * path: /path/to/file.txt
+ * file: file.txt
+ * dir: /path/to
+ */
+static int sqfs_split_path(char **file, char **dir, const char *path)
+{
+	char *dirc, *basec, *bname, *dname, *tmp_path;
+	int ret = 0;
+
+	*file = NULL;
+	*dir = NULL;
+	dirc = NULL;
+	basec = NULL;
+	bname = NULL;
+	dname = NULL;
+	tmp_path = NULL;
+
+	/* check for first slash in path*/
+	if (path[0] == '/') {
+		tmp_path = strdup(path);
+		if (!tmp_path) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	} else {
+		tmp_path = malloc(strlen(path) + 2);
+		if (!tmp_path) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		tmp_path[0] = '/';
+		strcpy(tmp_path + 1, path);
+	}
+
+	/* String duplicates */
+	dirc = strdup(tmp_path);
+	if (!dirc) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	basec = strdup(tmp_path);
+	if (!basec) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	dname = sqfs_dirname(dirc);
+	bname = sqfs_basename(basec);
+
+	*file = strdup(bname);
+
+	if (!*file) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (*dname == '\0') {
+		*dir = malloc(2);
+		if (!*dir) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		(*dir)[0] = '/';
+		(*dir)[1] = '\0';
+	} else {
+		*dir = strdup(dname);
+		if (!*dir) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+out:
+	if (ret) {
+		free(*file);
+		free(*dir);
+		*dir = NULL;
+		*file = NULL;
+	}
+	free(basec);
+	free(dirc);
+	free(tmp_path);
+
+	return ret;
+}
+
+static int sqfs_get_regfile_info(struct squashfs_reg_inode *reg,
+				 struct squashfs_file_info *finfo,
+				 struct squashfs_fragment_block_entry *fentry,
+				 __le32 blksz)
+{
+	int datablk_count = 0, ret;
+
+	finfo->size = get_unaligned_le32(&reg->file_size);
+	finfo->offset = get_unaligned_le32(&reg->offset);
+	finfo->start = get_unaligned_le32(&reg->start_block);
+	finfo->frag = SQFS_IS_FRAGMENTED(get_unaligned_le32(&reg->fragment));
+
+	if (finfo->frag && finfo->offset == 0xFFFFFFFF)
+		return -EINVAL;
+
+	if (finfo->size < 1 || finfo->start == 0xFFFFFFFF)
+		return -EINVAL;
+
+	if (finfo->frag) {
+		datablk_count = finfo->size / le32_to_cpu(blksz);
+		ret = sqfs_frag_lookup(get_unaligned_le32(&reg->fragment),
+				       fentry);
+		if (ret < 0)
+			return -EINVAL;
+		finfo->comp = ret;
+		if (fentry->size < 1 || fentry->start == 0x7FFFFFFF)
+			return -EINVAL;
+	} else {
+		datablk_count = DIV_ROUND_UP(finfo->size, le32_to_cpu(blksz));
+	}
+
+	finfo->blk_sizes = malloc(datablk_count * sizeof(u32));
+	if (!finfo->blk_sizes)
+		return -ENOMEM;
+
+	return datablk_count;
+}
+
+static int sqfs_get_lregfile_info(struct squashfs_lreg_inode *lreg,
+				  struct squashfs_file_info *finfo,
+				  struct squashfs_fragment_block_entry *fentry,
+				 __le32 blksz)
+{
+	int datablk_count = 0, ret;
+
+	finfo->size = get_unaligned_le64(&lreg->file_size);
+	finfo->offset = get_unaligned_le32(&lreg->offset);
+	finfo->start = get_unaligned_le64(&lreg->start_block);
+	finfo->frag = SQFS_IS_FRAGMENTED(get_unaligned_le32(&lreg->fragment));
+
+	if (finfo->frag && finfo->offset == 0xFFFFFFFF)
+		return -EINVAL;
+
+	if (finfo->size < 1 || finfo->start == 0x7FFFFFFF)
+		return -EINVAL;
+
+	if (finfo->frag) {
+		datablk_count = finfo->size / le32_to_cpu(blksz);
+		ret = sqfs_frag_lookup(get_unaligned_le32(&lreg->fragment),
+				       fentry);
+		if (ret < 0)
+			return -EINVAL;
+		finfo->comp = ret;
+		if (fentry->size < 1 || fentry->start == 0x7FFFFFFF)
+			return -EINVAL;
+	} else {
+		datablk_count = DIV_ROUND_UP(finfo->size, le32_to_cpu(blksz));
+	}
+
+	finfo->blk_sizes = malloc(datablk_count * sizeof(u32));
+	if (!finfo->blk_sizes)
+		return -ENOMEM;
+
+	return datablk_count;
+}
+
+int sqfs_read(const char *filename, void *buf, loff_t offset, loff_t len,
+	      loff_t *actread)
+{
+	char *dir = NULL, *fragment_block, *datablock = NULL, *data_buffer = NULL;
+	char *fragment = NULL, *file = NULL, *resolved, *data;
+	u64 start, n_blks, table_size, data_offset, table_offset, sparse_size;
+	int ret, j, i_number, datablk_count = 0;
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	struct squashfs_fragment_block_entry frag_entry;
+	struct squashfs_file_info finfo = {0};
+	struct squashfs_symlink_inode *symlink;
+	struct fs_dir_stream *dirsp = NULL;
+	struct squashfs_dir_stream *dirs;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_base_inode *base;
+	struct squashfs_reg_inode *reg;
+	unsigned long dest_len;
+	struct fs_dirent *dent;
+	unsigned char *ipos;
+
+	*actread = 0;
+
+	if (offset) {
+		/*
+		 * TODO: implement reading at an offset in file
+		 */
+		printf("Error: reading at a specific offset in a squashfs file is not supported yet.\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * sqfs_opendir will uncompress inode and directory tables, and will
+	 * return a pointer to the directory that contains the requested file.
+	 */
+	sqfs_split_path(&file, &dir, filename);
+	ret = sqfs_opendir(dir, &dirsp);
+	if (ret) {
+		goto out;
+	}
+
+	dirs = (struct squashfs_dir_stream *)dirsp;
+
+	/* For now, only regular files are able to be loaded */
+	while (!sqfs_readdir(dirsp, &dent)) {
+		ret = strcmp(dent->name, file);
+		if (!ret)
+			break;
+
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	if (ret) {
+		printf("File not found.\n");
+		*actread = 0;
+		ret = -ENOENT;
+		goto out;
+	}
+
+	i_number = dirs->dir_header->inode_number + dirs->entry->inode_offset;
+	ipos = sqfs_find_inode(dirs->inode_table, i_number, sblk->inodes,
+			       sblk->block_size);
+
+	base = (struct squashfs_base_inode *)ipos;
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_REG_TYPE:
+		reg = (struct squashfs_reg_inode *)ipos;
+		datablk_count = sqfs_get_regfile_info(reg, &finfo, &frag_entry,
+						      sblk->block_size);
+		if (datablk_count < 0) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(finfo.blk_sizes, ipos + sizeof(*reg),
+		       datablk_count * sizeof(u32));
+		break;
+	case SQFS_LREG_TYPE:
+		lreg = (struct squashfs_lreg_inode *)ipos;
+		datablk_count = sqfs_get_lregfile_info(lreg, &finfo,
+						       &frag_entry,
+						       sblk->block_size);
+		if (datablk_count < 0) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(finfo.blk_sizes, ipos + sizeof(*lreg),
+		       datablk_count * sizeof(u32));
+		break;
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE:
+		symlink = (struct squashfs_symlink_inode *)ipos;
+		resolved = sqfs_resolve_symlink(symlink, filename);
+		ret = sqfs_read(resolved, buf, offset, len, actread);
+		free(resolved);
+		goto out;
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+	default:
+		printf("Unsupported entry type\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* If the user specifies a length, check its sanity */
+	if (len) {
+		if (len > finfo.size) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		finfo.size = len;
+	} else {
+		len = finfo.size;
+	}
+
+	if (datablk_count) {
+		data_offset = finfo.start;
+		datablock = malloc(get_unaligned_le32(&sblk->block_size));
+		if (!datablock) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	for (j = 0; j < datablk_count; j++) {
+		start = data_offset / ctxt.cur_dev->blksz;
+		table_size = SQFS_BLOCK_SIZE(finfo.blk_sizes[j]);
+		table_offset = data_offset - (start * ctxt.cur_dev->blksz);
+		n_blks = DIV_ROUND_UP(table_size + table_offset,
+				      ctxt.cur_dev->blksz);
+
+		/* Don't load any data for sparse blocks */
+		if (finfo.blk_sizes[j] == 0) {
+			n_blks = 0;
+			table_offset = 0;
+			data_buffer = NULL;
+			data = NULL;
+		} else {
+			data_buffer = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+
+			if (!data_buffer) {
+				ret = -ENOMEM;
+				goto out;
+			}
+
+			ret = sqfs_disk_read(start, n_blks, data_buffer);
+			if (ret < 0) {
+				/*
+				 * Possible causes: too many data blocks or too large
+				 * SquashFS block size. Tip: re-compile the SquashFS
+				 * image with mksquashfs's -b <block_size> option.
+				 */
+				printf("Error: too many data blocks to be read.\n");
+				goto out;
+			}
+
+			data = data_buffer + table_offset;
+		}
+
+		/* Load the data */
+		if (finfo.blk_sizes[j] == 0) {
+			/* This is a sparse block */
+			sparse_size = get_unaligned_le32(&sblk->block_size);
+			if ((*actread + sparse_size) > len)
+				sparse_size = len - *actread;
+			memset(buf + *actread, 0, sparse_size);
+			*actread += sparse_size;
+		} else if (SQFS_COMPRESSED_BLOCK(finfo.blk_sizes[j])) {
+			dest_len = get_unaligned_le32(&sblk->block_size);
+			ret = sqfs_decompress(&ctxt, datablock, &dest_len,
+					      data, table_size);
+			if (ret)
+				goto out;
+
+			if ((*actread + dest_len) > len)
+				dest_len = len - *actread;
+			memcpy(buf + *actread, datablock, dest_len);
+			*actread += dest_len;
+		} else {
+			if ((*actread + table_size) > len)
+				table_size = len - *actread;
+			memcpy(buf + *actread, data, table_size);
+			*actread += table_size;
+		}
+
+		data_offset += table_size;
+		if (data_buffer)
+			free(data_buffer);
+		data_buffer = NULL;
+		if (*actread >= len)
+			break;
+	}
+
+	/*
+	 * There is no need to continue if the file is not fragmented.
+	 */
+	if (!finfo.frag) {
+		ret = 0;
+		goto out;
+	}
+
+	start = frag_entry.start / ctxt.cur_dev->blksz;
+	table_size = SQFS_BLOCK_SIZE(frag_entry.size);
+	table_offset = frag_entry.start - (start * ctxt.cur_dev->blksz);
+	n_blks = DIV_ROUND_UP(table_size + table_offset, ctxt.cur_dev->blksz);
+
+	fragment = malloc_cache_aligned(n_blks * ctxt.cur_dev->blksz);
+
+	if (!fragment) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = sqfs_disk_read(start, n_blks, fragment);
+	if (ret < 0)
+		goto out;
+
+	/* File compressed and fragmented */
+	if (finfo.frag && finfo.comp) {
+		dest_len = get_unaligned_le32(&sblk->block_size);
+		fragment_block = malloc(dest_len);
+		if (!fragment_block) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		ret = sqfs_decompress(&ctxt, fragment_block, &dest_len,
+				      (void *)fragment  + table_offset,
+				      frag_entry.size);
+		if (ret) {
+			free(fragment_block);
+			goto out;
+		}
+
+		memcpy(buf + *actread, &fragment_block[finfo.offset], finfo.size - *actread);
+		*actread = finfo.size;
+
+		free(fragment_block);
+
+	} else if (finfo.frag && !finfo.comp) {
+		fragment_block = (void *)fragment + table_offset;
+
+		memcpy(buf + *actread, &fragment_block[finfo.offset], finfo.size - *actread);
+		*actread = finfo.size;
+	}
+
+out:
+	free(fragment);
+	if (datablk_count) {
+		free(data_buffer);
+		free(datablock);
+	}
+	free(file);
+	free(dir);
+	free(finfo.blk_sizes);
+	sqfs_closedir(dirsp);
+
+	return ret;
+}
+
+int sqfs_size(const char *filename, loff_t *size)
+{
+	struct squashfs_super_block *sblk = ctxt.sblk;
+	struct squashfs_symlink_inode *symlink;
+	struct fs_dir_stream *dirsp = NULL;
+	struct squashfs_base_inode *base;
+	struct squashfs_dir_stream *dirs;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_reg_inode *reg;
+	char *dir, *file, *resolved;
+	struct fs_dirent *dent;
+	unsigned char *ipos;
+	int ret, i_number;
+
+	sqfs_split_path(&file, &dir, filename);
+	/*
+	 * sqfs_opendir will uncompress inode and directory tables, and will
+	 * return a pointer to the directory that contains the requested file.
+	 */
+	ret = sqfs_opendir(dir, &dirsp);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_strings;
+	}
+
+	dirs = (struct squashfs_dir_stream *)dirsp;
+
+	while (!sqfs_readdir(dirsp, &dent)) {
+		ret = strcmp(dent->name, file);
+		if (!ret)
+			break;
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	if (ret) {
+		printf("File not found.\n");
+		*size = 0;
+		ret = -EINVAL;
+		goto free_strings;
+	}
+
+	i_number = dirs->dir_header->inode_number + dirs->entry->inode_offset;
+	ipos = sqfs_find_inode(dirs->inode_table, i_number, sblk->inodes,
+			       sblk->block_size);
+	free(dirs->entry);
+	dirs->entry = NULL;
+
+	base = (struct squashfs_base_inode *)ipos;
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_REG_TYPE:
+		reg = (struct squashfs_reg_inode *)ipos;
+		*size = get_unaligned_le32(&reg->file_size);
+		break;
+	case SQFS_LREG_TYPE:
+		lreg = (struct squashfs_lreg_inode *)ipos;
+		*size = get_unaligned_le64(&lreg->file_size);
+		break;
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE:
+		symlink = (struct squashfs_symlink_inode *)ipos;
+		resolved = sqfs_resolve_symlink(symlink, filename);
+		ret = sqfs_size(resolved, size);
+		free(resolved);
+		break;
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+	default:
+		printf("Unable to recover entry's size.\n");
+		*size = 0;
+		ret = -EINVAL;
+		break;
+	}
+
+free_strings:
+	free(dir);
+	free(file);
+
+	sqfs_closedir(dirsp);
+
+	return ret;
+}
+
+int sqfs_exists(const char *filename)
+{
+	struct fs_dir_stream *dirsp = NULL;
+	struct squashfs_dir_stream *dirs;
+	char *dir, *file;
+	struct fs_dirent *dent;
+	int ret;
+
+	sqfs_split_path(&file, &dir, filename);
+	/*
+	 * sqfs_opendir will uncompress inode and directory tables, and will
+	 * return a pointer to the directory that contains the requested file.
+	 */
+	ret = sqfs_opendir(dir, &dirsp);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_strings;
+	}
+
+	dirs = (struct squashfs_dir_stream *)dirsp;
+
+	while (!sqfs_readdir(dirsp, &dent)) {
+		ret = strcmp(dent->name, file);
+		if (!ret)
+			break;
+		free(dirs->entry);
+		dirs->entry = NULL;
+	}
+
+	sqfs_closedir(dirsp);
+
+free_strings:
+	free(dir);
+	free(file);
+
+	return ret == 0;
+}
+
+void sqfs_close(void)
+{
+	sqfs_decompressor_cleanup(&ctxt);
+	free(ctxt.sblk);
+	ctxt.sblk = NULL;
+	ctxt.cur_dev = NULL;
+}
+
+void sqfs_closedir(struct fs_dir_stream *dirs)
+{
+	struct squashfs_dir_stream *sqfs_dirs;
+
+	if (!dirs)
+		return;
+
+	sqfs_dirs = (struct squashfs_dir_stream *)dirs;
+	free(sqfs_dirs->inode_table);
+	free(sqfs_dirs->dir_table);
+	free(sqfs_dirs->dir_header);
+	free(sqfs_dirs);
+}
diff --git a/fs/squashfs/sqfs_decompressor.c b/fs/squashfs/sqfs_decompressor.c
new file mode 100644
index 00000000000..eb76d24459e
--- /dev/null
+++ b/fs/squashfs/sqfs_decompressor.c
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#if IS_ENABLED(CONFIG_LZO)
+#include <linux/lzo.h>
+#endif
+
+#include "sqfs_decompressor.h"
+#include "sqfs_utils.h"
+
+int sqfs_decompressor_init(struct squashfs_ctxt *ctxt)
+{
+	u16 comp_type = get_unaligned_le16(&ctxt->sblk->compression);
+
+	switch (comp_type) {
+#if IS_ENABLED(CONFIG_LZO)
+	case SQFS_COMP_LZO:
+		break;
+#endif
+	default:
+		printf("Error: unknown compression type.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void sqfs_decompressor_cleanup(struct squashfs_ctxt *ctxt)
+{
+	u16 comp_type = get_unaligned_le16(&ctxt->sblk->compression);
+
+	switch (comp_type) {
+#if IS_ENABLED(CONFIG_LZO)
+	case SQFS_COMP_LZO:
+		break;
+#endif
+	}
+}
+
+int sqfs_decompress(struct squashfs_ctxt *ctxt, void *dest,
+		    unsigned long *dest_len, void *source, u32 src_len)
+{
+	u16 comp_type = get_unaligned_le16(&ctxt->sblk->compression);
+	int ret = 0;
+
+	switch (comp_type) {
+#if IS_ENABLED(CONFIG_LZO)
+	case SQFS_COMP_LZO: {
+		size_t lzo_dest_len = *dest_len;
+		ret = lzo1x_decompress_safe(source, src_len, dest, &lzo_dest_len);
+		if (ret) {
+			printf("LZO decompression failed. Error code: %d\n", ret);
+			return -EINVAL;
+		}
+
+		break;
+	}
+#endif
+	default:
+		printf("Error: unknown compression type.\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
diff --git a/fs/squashfs/sqfs_decompressor.h b/fs/squashfs/sqfs_decompressor.h
new file mode 100644
index 00000000000..e9938a67037
--- /dev/null
+++ b/fs/squashfs/sqfs_decompressor.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#ifndef SQFS_DECOMPRESSOR_H
+#define SQFS_DECOMPRESSOR_H
+
+#include "sqfs_filesystem.h"
+
+#define SQFS_COMP_ZLIB 1
+#define SQFS_COMP_LZMA 2
+#define SQFS_COMP_LZO 3
+#define SQFS_COMP_XZ 4
+#define SQFS_COMP_LZ4 5
+#define SQFS_COMP_ZSTD 6
+
+/* LZMA does not support any compression options */
+
+struct squashfs_gzip_opts {
+	u32 compression_level;
+	u16 window_size;
+	u16 strategies;
+};
+
+struct squashfs_xz_opts {
+	u32 dictionary_size;
+	u32 executable_filters;
+};
+
+struct squashfs_lz4_opts {
+	u32 version;
+	u32 flags;
+};
+
+struct squashfs_zstd_opts {
+	u32 compression_level;
+};
+
+struct squashfs_lzo_opts {
+	u32 algorithm;
+	u32 level;
+};
+
+union squashfs_compression_opts {
+	struct squashfs_gzip_opts *gzip;
+	struct squashfs_xz_opts *xz;
+	struct squashfs_lz4_opts *lz4;
+	struct squashfs_zstd_opts *zstd;
+	struct squashfs_lzo_opts *lzo;
+};
+
+int sqfs_decompress(struct squashfs_ctxt *ctxt, void *dest,
+		    unsigned long *dest_len, void *source, u32 src_len);
+int sqfs_decompressor_init(struct squashfs_ctxt *ctxt);
+void sqfs_decompressor_cleanup(struct squashfs_ctxt *ctxt);
+
+#endif /* SQFS_DECOMPRESSOR_H */
diff --git a/fs/squashfs/sqfs_dir.c b/fs/squashfs/sqfs_dir.c
new file mode 100644
index 00000000000..c18abcc25fe
--- /dev/null
+++ b/fs/squashfs/sqfs_dir.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#include <errno.h>
+#include <linux/types.h>
+#include <linux/byteorder/little_endian.h>
+#include <linux/byteorder/generic.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "sqfs_filesystem.h"
+#include "sqfs_utils.h"
+
+bool sqfs_is_dir(u16 type)
+{
+	return type == SQFS_DIR_TYPE || type == SQFS_LDIR_TYPE;
+}
+
+/*
+ * Receives a pointer (void *) to a position in the inode table containing the
+ * directory's inode. Returns directory inode offset into the directory table.
+ * m_list contains each metadata block's position, and m_count is the number of
+ * elements of m_list. Those metadata blocks come from the compressed directory
+ * table.
+ */
+int sqfs_dir_offset(void *dir_i, u32 *m_list, int m_count)
+{
+	struct squashfs_base_inode *base = dir_i;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_dir_inode *dir;
+	u32 start_block;
+	int j, offset;
+
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_DIR_TYPE:
+		dir = (struct squashfs_dir_inode *)base;
+		start_block = get_unaligned_le32(&dir->start_block);
+		offset = get_unaligned_le16(&dir->offset);
+		break;
+	case SQFS_LDIR_TYPE:
+		ldir = (struct squashfs_ldir_inode *)base;
+		start_block = get_unaligned_le32(&ldir->start_block);
+		offset = get_unaligned_le16(&ldir->offset);
+		break;
+	default:
+		printf("Error: this is not a directory.\n");
+		return -EINVAL;
+	}
+
+	if (offset < 0)
+		return -EINVAL;
+
+	for (j = 0; j < m_count; j++) {
+		if (m_list[j] == start_block)
+			return (++j * SQFS_METADATA_BLOCK_SIZE) + offset;
+	}
+
+	if (start_block == 0)
+		return offset;
+
+	printf("Error: invalid inode reference to directory table.\n");
+
+	return -EINVAL;
+}
+
+bool sqfs_is_empty_dir(void *dir_i)
+{
+	struct squashfs_base_inode *base = dir_i;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_dir_inode *dir;
+	u32 file_size;
+
+	switch (get_unaligned_le16(&base->inode_type)) {
+	case SQFS_DIR_TYPE:
+		dir = (struct squashfs_dir_inode *)base;
+		file_size = get_unaligned_le16(&dir->file_size);
+		break;
+	case SQFS_LDIR_TYPE:
+		ldir = (struct squashfs_ldir_inode *)base;
+		file_size = get_unaligned_le16(&ldir->file_size);
+		break;
+	default:
+		printf("Error: this is not a directory.\n");
+		return false;
+	}
+
+	return file_size == SQFS_EMPTY_FILE_SIZE;
+}
diff --git a/fs/squashfs/sqfs_filesystem.h b/fs/squashfs/sqfs_filesystem.h
new file mode 100644
index 00000000000..8c064f1f67a
--- /dev/null
+++ b/fs/squashfs/sqfs_filesystem.h
@@ -0,0 +1,306 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#ifndef SQFS_FILESYSTEM_H
+#define SQFS_FILESYSTEM_H
+
+#include <asm/unaligned.h>
+#include <fs.h>
+#include <part.h>
+
+#define SQFS_UNCOMPRESSED_DATA 0x0002
+#define SQFS_MAGIC_NUMBER 0x73717368
+/* The three first members of squashfs_dir_index make a total of 12 bytes */
+#define SQFS_DIR_INDEX_BASE_LENGTH 12
+/* size of metadata (inode and directory) blocks */
+#define SQFS_METADATA_BLOCK_SIZE 8192
+/* Max. number of fragment entries in a metadata block is 512 */
+#define SQFS_MAX_ENTRIES 512
+/* Metadata blocks start by a 2-byte length header */
+#define SQFS_HEADER_SIZE 2
+#define SQFS_LREG_INODE_MIN_SIZE 56
+#define SQFS_DIR_HEADER_SIZE 12
+#define SQFS_MISC_ENTRY_TYPE -1
+#define SQFS_EMPTY_FILE_SIZE 3
+#define SQFS_STOP_READDIR 1
+#define SQFS_EMPTY_DIR -1
+/*
+ * A directory entry object has a fixed length of 8 bytes, corresponding to its
+ * first four members, plus the size of the entry name, which is equal to
+ * 'entry_name' + 1 bytes.
+ */
+#define SQFS_ENTRY_BASE_LENGTH 8
+/* Inode types */
+#define SQFS_DIR_TYPE 1
+#define SQFS_REG_TYPE 2
+#define SQFS_SYMLINK_TYPE 3
+#define SQFS_BLKDEV_TYPE 4
+#define SQFS_CHRDEV_TYPE 5
+#define SQFS_FIFO_TYPE 6
+#define SQFS_SOCKET_TYPE 7
+#define SQFS_LDIR_TYPE 8
+#define SQFS_LREG_TYPE 9
+#define SQFS_LSYMLINK_TYPE 10
+#define SQFS_LBLKDEV_TYPE 11
+#define SQFS_LCHRDEV_TYPE 12
+#define SQFS_LFIFO_TYPE 13
+#define SQFS_LSOCKET_TYPE 14
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 inodes;
+	__le32 mkfs_time;
+	__le32 block_size;
+	__le32 fragments;
+	__le16 compression;
+	__le16 block_log;
+	__le16 flags;
+	__le16 no_ids;
+	__le16 s_major;
+	__le16 s_minor;
+	__le64 root_inode;
+	__le64 bytes_used;
+	__le64 id_table_start;
+	__le64 xattr_id_table_start;
+	__le64 inode_table_start;
+	__le64 directory_table_start;
+	__le64 fragment_table_start;
+	__le64 export_table_start;
+};
+
+struct squashfs_ctxt {
+	struct disk_partition cur_part_info;
+	struct blk_desc *cur_dev;
+	struct squashfs_super_block *sblk;
+};
+
+struct squashfs_directory_index {
+	u32 index;
+	u32 start;
+	u32 size;
+	char name[0];
+};
+
+struct squashfs_base_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+};
+
+struct squashfs_ipc_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+};
+
+struct squashfs_lipc_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 xattr;
+};
+
+struct squashfs_dev_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 rdev;
+};
+
+struct squashfs_ldev_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 rdev;
+	__le32 xattr;
+};
+
+struct squashfs_symlink_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 symlink_size;
+	char symlink[0];
+};
+
+struct squashfs_reg_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 start_block;
+	__le32 fragment;
+	__le32 offset;
+	__le32 file_size;
+	__le32 block_list[0];
+};
+
+struct squashfs_lreg_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le64 start_block;
+	__le64 file_size;
+	__le64 sparse;
+	__le32 nlink;
+	__le32 fragment;
+	__le32 offset;
+	__le32 xattr;
+	__le32 block_list[0];
+};
+
+struct squashfs_dir_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 start_block;
+	__le32 nlink;
+	__le16 file_size;
+	__le16 offset;
+	__le32 parent_inode;
+};
+
+struct squashfs_ldir_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 file_size;
+	__le32 start_block;
+	__le32 parent_inode;
+	__le16 i_count;
+	__le16 offset;
+	__le32 xattr;
+	struct squashfs_directory_index index[0];
+};
+
+union squashfs_inode {
+	struct squashfs_base_inode *base;
+	struct squashfs_dev_inode *dev;
+	struct squashfs_ldev_inode *ldev;
+	struct squashfs_symlink_inode *symlink;
+	struct squashfs_reg_inode *reg;
+	struct squashfs_lreg_inode *lreg;
+	struct squashfs_dir_inode *dir;
+	struct squashfs_ldir_inode *ldir;
+	struct squashfs_ipc_inode *ipc;
+	struct squashfs_lipc_inode *lipc;
+};
+
+struct squashfs_directory_entry {
+	u16 offset;
+	u16 inode_offset;
+	u16 type;
+	u16 name_size;
+	char name[0];
+};
+
+struct squashfs_directory_header {
+	u32 count;
+	u32 start;
+	u32 inode_number;
+};
+
+struct squashfs_fragment_block_entry {
+	u64 start;
+	u32 size;
+	u32 _unused;
+};
+
+struct squashfs_dir_stream {
+	struct fs_dir_stream fs_dirs;
+	struct fs_dirent dentp;
+	/*
+	 * 'size' is the uncompressed size of the entire listing, including
+	 * headers. 'entry_count' is the number of entries following a
+	 * specific header. Both variables are decremented in sqfs_readdir() so
+	 * the function knows when the end of the directory is reached.
+	 */
+	size_t size;
+	int entry_count;
+	/* SquashFS structures */
+	struct squashfs_directory_header *dir_header;
+	struct squashfs_directory_entry *entry;
+	/*
+	 * 'table' points to a position into the directory table. Both 'table'
+	 * and 'inode' are defined for the first time in sqfs_opendir().
+	 * 'table's value changes in sqfs_readdir().
+	 */
+	unsigned char *table;
+	union squashfs_inode i;
+	struct squashfs_dir_inode i_dir;
+	struct squashfs_ldir_inode i_ldir;
+	/*
+	 * References to the tables' beginnings. They are assigned in
+	 * sqfs_opendir() and freed in sqfs_closedir().
+	 */
+	unsigned char *inode_table;
+	unsigned char *dir_table;
+};
+
+struct squashfs_file_info {
+	/* File size in bytes (uncompressed) */
+	size_t size;
+	/* Reference to list of data blocks's sizes */
+	u32 *blk_sizes;
+	/* Offset into the fragment block */
+	u32 offset;
+	/* Offset in which the data blocks begin */
+	u64 start;
+	/* Is file fragmented? */
+	bool frag;
+	/* Compressed fragment */
+	bool comp;
+};
+
+void *sqfs_find_inode(void *inode_table, int inode_number, __le32 inode_count,
+		      __le32 block_size);
+
+int sqfs_dir_offset(void *dir_i, u32 *m_list, int m_count);
+
+int sqfs_read_metablock(unsigned char *file_mapping, int offset,
+			bool *compressed, u32 *data_size);
+
+bool sqfs_is_empty_dir(void *dir_i);
+
+bool sqfs_is_dir(u16 type);
+
+#endif /* SQFS_FILESYSTEM_H */
diff --git a/fs/squashfs/sqfs_inode.c b/fs/squashfs/sqfs_inode.c
new file mode 100644
index 00000000000..39ae86be3b6
--- /dev/null
+++ b/fs/squashfs/sqfs_inode.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#include <asm/unaligned.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/string.h>
+
+#include "sqfs_decompressor.h"
+#include "sqfs_filesystem.h"
+#include "sqfs_utils.h"
+
+int sqfs_inode_size(struct squashfs_base_inode *inode, u32 blk_size)
+{
+	switch (get_unaligned_le16(&inode->inode_type)) {
+	case SQFS_DIR_TYPE:
+		return sizeof(struct squashfs_dir_inode);
+
+	case SQFS_REG_TYPE: {
+		struct squashfs_reg_inode *reg =
+			(struct squashfs_reg_inode *)inode;
+		u32 fragment = get_unaligned_le32(&reg->fragment);
+		u32 file_size = get_unaligned_le32(&reg->file_size);
+		unsigned int blk_list_size;
+
+		if (SQFS_IS_FRAGMENTED(fragment))
+			blk_list_size = file_size / blk_size;
+		else
+			blk_list_size = DIV_ROUND_UP(file_size, blk_size);
+
+		return sizeof(*reg) + blk_list_size * sizeof(u32);
+	}
+
+	case SQFS_LDIR_TYPE: {
+		struct squashfs_ldir_inode *ldir =
+			(struct squashfs_ldir_inode *)inode;
+		u16 i_count = get_unaligned_le16(&ldir->i_count);
+		unsigned int index_list_size = 0, l = 0;
+		struct squashfs_directory_index *di;
+		u32 sz;
+
+		if (i_count == 0)
+			return sizeof(*ldir);
+
+		di = ldir->index;
+		while (l < i_count) {
+			sz = get_unaligned_le32(&di->size) + 1;
+			index_list_size += sz;
+			di = (void *)di + sizeof(*di) + sz;
+			l++;
+		}
+
+		return sizeof(*ldir) + index_list_size +
+			i_count * SQFS_DIR_INDEX_BASE_LENGTH;
+	}
+
+	case SQFS_LREG_TYPE: {
+		struct squashfs_lreg_inode *lreg =
+			(struct squashfs_lreg_inode *)inode;
+		u32 fragment = get_unaligned_le32(&lreg->fragment);
+		u64 file_size = get_unaligned_le64(&lreg->file_size);
+		unsigned int blk_list_size;
+
+		if (fragment == 0xFFFFFFFF)
+			blk_list_size = DIV_ROUND_UP(file_size, blk_size);
+		else
+			blk_list_size = file_size / blk_size;
+
+		return sizeof(*lreg) + blk_list_size * sizeof(u32);
+	}
+
+	case SQFS_SYMLINK_TYPE:
+	case SQFS_LSYMLINK_TYPE: {
+		struct squashfs_symlink_inode *symlink =
+			(struct squashfs_symlink_inode *)inode;
+
+		return sizeof(*symlink) +
+			get_unaligned_le32(&symlink->symlink_size);
+	}
+
+	case SQFS_BLKDEV_TYPE:
+	case SQFS_CHRDEV_TYPE:
+		return sizeof(struct squashfs_dev_inode);
+	case SQFS_LBLKDEV_TYPE:
+	case SQFS_LCHRDEV_TYPE:
+		return sizeof(struct squashfs_ldev_inode);
+	case SQFS_FIFO_TYPE:
+	case SQFS_SOCKET_TYPE:
+		return sizeof(struct squashfs_ipc_inode);
+	case SQFS_LFIFO_TYPE:
+	case SQFS_LSOCKET_TYPE:
+		return sizeof(struct squashfs_lipc_inode);
+	default:
+		printf("Error while searching inode: unknown type.\n");
+		return -EINVAL;
+	}
+}
+
+/*
+ * Given the uncompressed inode table, the inode to be found and the number of
+ * inodes in the table, return inode position in case of success.
+ */
+void *sqfs_find_inode(void *inode_table, int inode_number, __le32 inode_count,
+		      __le32 block_size)
+{
+	struct squashfs_base_inode *base;
+	unsigned int offset = 0, k;
+	int sz;
+
+	if (!inode_table) {
+		printf("%s: Invalid pointer to inode table.\n", __func__);
+		return NULL;
+	}
+
+	for (k = 0; k < le32_to_cpu(inode_count); k++) {
+		base = inode_table + offset;
+		if (get_unaligned_le32(&base->inode_number) == inode_number)
+			return inode_table + offset;
+
+		sz = sqfs_inode_size(base, le32_to_cpu(block_size));
+		if (sz < 0)
+			return NULL;
+
+		offset += sz;
+	}
+
+	printf("Inode not found.\n");
+
+	return NULL;
+}
+
+int sqfs_read_metablock(unsigned char *file_mapping, int offset,
+			bool *compressed, u32 *data_size)
+{
+	const unsigned char *data;
+	u16 header;
+
+	if (!file_mapping)
+		return -EFAULT;
+	data = file_mapping + offset;
+
+	header = get_unaligned((u16 *)data);
+	if (!header)
+		return -EINVAL;
+
+	*compressed = SQFS_COMPRESSED_METADATA(header);
+	*data_size = SQFS_METADATA_SIZE(header);
+
+	if (*data_size > SQFS_METADATA_BLOCK_SIZE) {
+		printf("Invalid metatada block size: %d bytes.\n", *data_size);
+		return -EINVAL;
+	}
+
+	return 0;
+}
diff --git a/fs/squashfs/sqfs_utils.h b/fs/squashfs/sqfs_utils.h
new file mode 100644
index 00000000000..1260abe22be
--- /dev/null
+++ b/fs/squashfs/sqfs_utils.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ */
+
+#ifndef SQFS_UTILS_H
+#define SQFS_UTILS_H
+
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <stdbool.h>
+
+#define SQFS_FRAGMENT_INDEX_OFFSET(A) ((A) % SQFS_MAX_ENTRIES)
+#define SQFS_FRAGMENT_INDEX(A) ((A) / SQFS_MAX_ENTRIES)
+#define SQFS_BLOCK_SIZE(A) ((A) & GENMASK(23, 0))
+#define SQFS_CHECK_FLAG(flag, bit) (((flag) >> (bit)) & 1)
+/* Useful for both fragment and data blocks */
+#define SQFS_COMPRESSED_BLOCK(A) (!((A) & BIT(24)))
+/* SQFS_COMPRESSED_DATA strictly used with super block's 'flags' member */
+#define SQFS_COMPRESSED_DATA(A) (!((A) & 0x0002))
+#define SQFS_IS_FRAGMENTED(A) ((A) != 0xFFFFFFFF)
+/*
+ * These two macros work as getters for a metada block header, retrieving the
+ * data size and if it is compressed/uncompressed
+ */
+#define SQFS_COMPRESSED_METADATA(A) (!((A) & BIT(15)))
+#define SQFS_METADATA_SIZE(A) ((A) & GENMASK(14, 0))
+
+struct squashfs_super_block_flags {
+	/* check: unused
+	 * uncompressed_ids: not supported
+	 */
+	bool uncompressed_inodes;
+	bool uncompressed_data;
+	bool check;
+	bool uncompressed_frags;
+	bool no_frags;
+	bool always_frags;
+	bool duplicates;
+	bool exportable;
+	bool uncompressed_xattrs;
+	bool no_xattrs;
+	bool compressor_options;
+	bool uncompressed_ids;
+};
+
+#endif /* SQFS_UTILS_H  */
diff --git a/include/fs.h b/include/fs.h
index 972be04115b..be1c8c22e7a 100644
--- a/include/fs.h
+++ b/include/fs.h
@@ -13,6 +13,7 @@
 #define FS_TYPE_EXT	2
 #define FS_TYPE_SANDBOX	3
 #define FS_TYPE_UBIFS	4
+#define FS_TYPE_SQUASHFS 5
 
 /*
  * Tell the fs layer which block device an partition to use for future
diff --git a/include/squashfs.h b/include/squashfs.h
new file mode 100644
index 00000000000..7489eefa1f2
--- /dev/null
+++ b/include/squashfs.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Bootlin
+ *
+ * Author: Joao Marcos Costa <joaomarcos.costa@bootlin.com>
+ *
+ * squashfs.h: SquashFS filesystem implementation.
+ */
+
+#ifndef _SQFS_H_
+#define _SQFS_H_
+
+struct disk_partition;
+
+int sqfs_opendir(const char *filename, struct fs_dir_stream **dirsp);
+int sqfs_readdir(struct fs_dir_stream *dirs, struct fs_dirent **dentp);
+int sqfs_probe(struct blk_desc *fs_dev_desc,
+	       struct disk_partition *fs_partition);
+int sqfs_read(const char *filename, void *buf, loff_t offset,
+	      loff_t len, loff_t *actread);
+int sqfs_size(const char *filename, loff_t *size);
+int sqfs_exists(const char *filename);
+void sqfs_close(void);
+void sqfs_closedir(struct fs_dir_stream *dirs);
+
+#endif /* SQFS_H  */
-- 
2.47.2

